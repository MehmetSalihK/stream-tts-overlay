<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>TTS Overlay</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background-color: transparent;
            overflow: hidden;
        }

        #message-container {
            position: fixed;
            top: 20px;
            left: 20px;
            max-width: 60%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            display: none;
            font-size: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transform: translateX(-120%);
            z-index: 9999; /* Assurer que le message est au-dessus de tout */
            opacity: 1;
            visibility: visible;
        }

        .username {
            color: #ff9900;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 22px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }

        .message {
            color: #ffffff;
            margin-bottom: 10px;
            line-height: 1.3;
            font-size: 20px;
        }

        .voice-info {
            color: #00ff00;
            font-style: italic;
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        @keyframes slideInFromLeft {
            0% { transform: translateX(-120%); }
            100% { transform: translateX(0); }
        }

        @keyframes slideOutToLeft {
            0% { transform: translateX(0); }
            100% { transform: translateX(-120%); }
        }

        .slide-in-left {
            animation: slideInFromLeft 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .slide-out-left {
            animation: slideOutToLeft 0.8s cubic-bezier(0.55, 0.085, 0.68, 0.53) forwards;
        }
    </style>
</head>
<body>
    <div id="message-container">
        <div class="username"></div>
        <div class="message"></div>
        <div class="voice-info"></div>
    </div>

    <audio id="tts-audio"></audio>

    <script>
        let currentAudio = null;
        let lastMessageId = null;
        let isProcessing = false;
        
        function showMessage(username, message, voice) {
            console.log('üìù Tentative d\'affichage du message:', { username, message, voice });
            
            // V√©rifier si le conteneur existe, sinon le cr√©er
            let container = document.getElementById('message-container');
            if (!container) {
                console.log('‚ö†Ô∏è Conteneur de message non trouv√©, cr√©ation...');
                container = document.createElement('div');
                container.id = 'message-container';
                document.body.appendChild(container);
            }
            
            // V√©rifier si les √©l√©ments enfants existent, sinon les cr√©er
            let usernameEl = container.querySelector('.username');
            if (!usernameEl) {
                console.log('‚ö†Ô∏è √âl√©ment username non trouv√©, cr√©ation...');
                usernameEl = document.createElement('div');
                usernameEl.className = 'username';
                container.appendChild(usernameEl);
            }
            
            let messageEl = container.querySelector('.message');
            if (!messageEl) {
                console.log('‚ö†Ô∏è √âl√©ment message non trouv√©, cr√©ation...');
                messageEl = document.createElement('div');
                messageEl.className = 'message';
                container.appendChild(messageEl);
            }
            
            let voiceEl = container.querySelector('.voice-info');
            if (!voiceEl) {
                console.log('‚ö†Ô∏è √âl√©ment voice-info non trouv√©, cr√©ation...');
                voiceEl = document.createElement('div');
                voiceEl.className = 'voice-info';
                container.appendChild(voiceEl);
            }
            
            // D√©finir le contenu avec des valeurs par d√©faut si n√©cessaire
            usernameEl.textContent = username || 'Utilisateur';
            messageEl.textContent = message || 'Message';
            voiceEl.textContent = voice ? `Lu par : ${voice}` : 'Lu par : voix par d√©faut';
            
            // Forcer la visibilit√© avec plusieurs propri√©t√©s CSS
            container.style.display = 'block';
            container.style.opacity = '1';
            container.style.visibility = 'visible';
            container.style.zIndex = '9999';
            
            // Ajouter l'animation
            container.classList.remove('slide-out-left');
            container.classList.add('slide-in-left');
            
            // V√©rifier si le conteneur est r√©ellement visible
            setTimeout(() => {
                const isVisible = window.getComputedStyle(container).display !== 'none' && 
                                window.getComputedStyle(container).opacity !== '0' &&
                                window.getComputedStyle(container).visibility !== 'hidden';
                console.log('üìù V√©rification de visibilit√©:', { 
                    isVisible, 
                    display: window.getComputedStyle(container).display,
                    opacity: window.getComputedStyle(container).opacity,
                    visibility: window.getComputedStyle(container).visibility,
                    width: container.offsetWidth,
                    height: container.offsetHeight,
                    position: `${container.offsetLeft},${container.offsetTop}`
                });
            }, 100);
            
            console.log('üìù Message affich√©:', { username, message, voice });
        }

        function hideMessage() {
            const container = document.getElementById('message-container');
            
            // V√©rifier si le conteneur existe
            if (!container) {
                console.log('‚ö†Ô∏è Tentative de cacher un message mais le conteneur n\'existe pas');
                return;
            }
            
            // V√©rifier si le message est d√©j√† cach√©
            const isHidden = container.style.display === 'none' || 
                           container.style.opacity === '0' || 
                           container.style.visibility === 'hidden' ||
                           container.classList.contains('slide-out-left');
            
            if (isHidden) {
                console.log('‚ÑπÔ∏è Le message est d√©j√† cach√©, aucune action n√©cessaire');
                return;
            }
            
            console.log('üö´ D√©but du processus pour cacher le message');
            container.classList.remove('slide-in-left');
            container.classList.add('slide-out-left');
            
            setTimeout(() => {
                container.style.display = 'none';
                container.style.opacity = '0';
                container.style.visibility = 'hidden';
                console.log('üö´ Message cach√©');
                
                // V√©rifier si le message est r√©ellement cach√©
                setTimeout(() => {
                    const isReallyHidden = container.style.display === 'none' || 
                                         window.getComputedStyle(container).opacity === '0' ||
                                         window.getComputedStyle(container).visibility === 'hidden';
                    console.log('üö´ V√©rification de masquage:', { isReallyHidden });
                }, 100);
            }, 800);
        }

        async function playAudio(data) {
            try {
                console.log('üéØ D√©but du traitement du message:', data);
                
                // V√©rifier si l'√©l√©ment audio existe, sinon le cr√©er
                let audio = document.getElementById('tts-audio');
                if (!audio) {
                    console.log('‚ö†Ô∏è √âl√©ment audio non trouv√©, cr√©ation...');
                    audio = document.createElement('audio');
                    audio.id = 'tts-audio';
                    document.body.appendChild(audio);
                }
                
                // Arr√™ter l'audio pr√©c√©dent et nettoyer
                if (currentAudio) {
                    console.log('‚èπÔ∏è Arr√™t de l\'audio pr√©c√©dent');
                    currentAudio.pause();
                    currentAudio.src = '';
                    currentAudio.load();
                }

                // Stocker l'ID du message actuel pour v√©rification
                const currentMessageId = data.timestamp;
                console.log(`üìå Traitement du message ID: ${currentMessageId}`);

                // Attendre que le statut soit "ready" avant de continuer (avec timeout)
                let attempts = 0;
                const maxAttempts = 50; // 5 secondes maximum d'attente
                
                while (data.status !== 'ready' && attempts < maxAttempts) {
                    console.log(`‚è≥ Attente de la g√©n√©ration audio... (tentative ${attempts+1}/${maxAttempts})`);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    try {
                        const response = await fetch('/current_message.json?' + Date.now());
                        if (!response.ok) {
                            console.log('‚ö†Ô∏è Erreur lors de la r√©cup√©ration du statut:', response.status);
                            continue;
                        }
                        data = await response.json();
                        
                        // V√©rifier si le message a chang√© pendant l'attente
                        if (data.timestamp !== currentMessageId) {
                            console.log('‚ö†Ô∏è Le message a chang√© pendant l\'attente, abandon du traitement');
                            return; // Sortir de la fonction, un nouveau message sera trait√© par checkForNewMessage
                        }
                    } catch (fetchError) {
                        console.error('‚ùå Erreur lors de la r√©cup√©ration du statut:', fetchError);
                    }
                    attempts++;
                }
                
                // Si on a atteint le nombre maximum de tentatives sans succ√®s
                if (attempts >= maxAttempts && data.status !== 'ready') {
                    console.error('‚ö†Ô∏è Timeout: La g√©n√©ration audio a pris trop de temps ou a √©chou√©');
                    // On continue quand m√™me pour essayer de lire l'audio s'il existe
                }

                console.log('‚úÖ Audio g√©n√©r√©, d√©but de la lecture');
                
                // D√©terminer l'URL du fichier audio √† utiliser
                let audioUrl;
                if (data.audioFile) {
                    // Utiliser le fichier audio sp√©cifique indiqu√© dans le message
                    audioUrl = '/' + data.audioFile + '?' + Date.now();
                    console.log(`üîä Utilisation du fichier audio sp√©cifique: ${data.audioFile}`);
                } else {
                    // Fallback vers le fichier audio.mp3 standard
                    audioUrl = '/audio.mp3?' + Date.now();
                    console.log('üîä Utilisation du fichier audio standard (audio.mp3)');
                }
                
                // V√©rifier si le fichier audio existe et a une taille correcte
                try {
                    const fileCheck = await fetch(audioUrl, { method: 'HEAD' });
                    if (!fileCheck.ok) {
                        console.error('‚ùå Le fichier audio n\'existe pas:', fileCheck.status);
                        throw new Error('Fichier audio non trouv√©');
                    }
                    
                    const contentLength = fileCheck.headers.get('content-length');
                    if (contentLength && parseInt(contentLength) < 100) {
                        console.error('‚ùå Le fichier audio est trop petit:', contentLength, 'octets');
                        throw new Error('Fichier audio invalide (trop petit)');
                    }
                    
                    console.log('‚úÖ V√©rification du fichier audio r√©ussie:', contentLength, 'octets');
                } catch (fileError) {
                    console.error('‚ùå Erreur lors de la v√©rification du fichier audio:', fileError);
                    // On continue quand m√™me pour essayer d'afficher le message
                }
                
                // V√©rifier une derni√®re fois que le message n'a pas chang√©
                try {
                    const finalCheck = await fetch('/current_message.json?' + Date.now());
                    if (finalCheck.ok) {
                        const latestData = await finalCheck.json();
                        if (latestData.timestamp !== currentMessageId) {
                            console.log('‚ö†Ô∏è Le message a chang√© avant la lecture, abandon');
                            return; // Sortir de la fonction
                        }
                    }
                } catch (checkError) {
                    console.error('‚ùå Erreur lors de la v√©rification finale:', checkError);
                }
                
                // D√©finir la source audio
                audio.src = audioUrl;
                currentAudio = audio;
                
                // Configurer les √©v√©nements de chargement audio
                let audioLoaded = false;
                const audioLoadTimeout = setTimeout(() => {
                    if (!audioLoaded) {
                        console.error('‚ö†Ô∏è Timeout: Le chargement audio a pris trop de temps');
                        // Afficher quand m√™me le message
                        showMessage(data.username, data.message, data.voice);
                    }
                }, 5000); // 5 secondes de timeout
                
                audio.oncanplay = () => {
                    console.log('üîä Audio pr√™t √† √™tre jou√© (oncanplay)');
                    audioLoaded = true;
                };
                
                audio.oncanplaythrough = () => {
                    console.log('üîä Audio compl√®tement charg√© (oncanplaythrough)');
                    clearTimeout(audioLoadTimeout);
                    audioLoaded = true;
                };
                
                audio.onloadstart = () => {
                    console.log('üîä D√©but du chargement audio (onloadstart)');
                };
                
                audio.ondurationchange = () => {
                    console.log('üîä Dur√©e audio d√©tect√©e:', audio.duration, 'secondes');
                };
                
                audio.onerror = (e) => {
                    console.error('‚ùå Erreur de chargement audio:', e);
                    clearTimeout(audioLoadTimeout);
                    // Afficher quand m√™me le message
                    showMessage(data.username, data.message, data.voice);
                };
                
                audio.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = (e.loaded / e.total) * 100;
                        console.log(`üîÑ Chargement audio: ${percentComplete.toFixed(1)}%`);
                    }
                };
                
                audio.onended = () => {
                    // Ajouter un d√©lai de 4 secondes avant de cacher le message
                    console.log('‚èπÔ∏è Lecture termin√©e, attente de 4 secondes avant de cacher le message');
                    setTimeout(() => {
                        hideMessage();
                        currentAudio = null;
                        isProcessing = false;
                        console.log('üö´ Message cach√© apr√®s d√©lai');
                    }, 4000); // 4 secondes de d√©lai
                };
                
                // Afficher le message AVANT de tenter de jouer l'audio
                if (data && data.username && data.message) {
                    showMessage(data.username, data.message, data.voice);
                } else {
                    console.error('‚ùå Donn√©es de message invalides:', data);
                }
                
                // V√©rifier si l'audio est dans un √©tat jouable
                const readyStateText = [
                    'HAVE_NOTHING (0) - Aucune information disponible',
                    'HAVE_METADATA (1) - M√©tadonn√©es disponibles',
                    'HAVE_CURRENT_DATA (2) - Donn√©es disponibles pour la position actuelle',
                    'HAVE_FUTURE_DATA (3) - Donn√©es disponibles pour la position actuelle et future',
                    'HAVE_ENOUGH_DATA (4) - Assez de donn√©es disponibles'
                ];
                
                console.log(`üîä √âtat de l'audio avant lecture: ${readyStateText[audio.readyState] || 'Inconnu'}`);
                
                // Tenter de jouer l'audio
                try {
                    audio.onplay = () => console.log('‚ñ∂Ô∏è √âv√©nement onplay d√©clench√©');
                    audio.onplaying = () => console.log('‚ñ∂Ô∏è √âv√©nement onplaying d√©clench√©');
                    
                    await audio.play();
                    console.log('‚ñ∂Ô∏è Lecture audio d√©marr√©e avec succ√®s');
                } catch (playError) {
                    console.error('‚ùå Erreur lors de la lecture audio:', playError);
                    console.log('‚ö†Ô∏è Tentative de rechargement et relecture apr√®s une pause...');
                    
                    // Tenter de recharger et rejouer apr√®s une courte pause
                    setTimeout(async () => {
                        try {
                            audio.load();
                            await audio.play();
                            console.log('‚ñ∂Ô∏è Relecture audio r√©ussie apr√®s rechargement');
                        } catch (retryError) {
                            console.error('‚ùå √âchec de la relecture audio:', retryError);
                            // Configurer un timeout pour cacher le message m√™me si l'audio ne peut pas √™tre jou√©
                            setTimeout(() => {
                                hideMessage();
                                currentAudio = null;
                                isProcessing = false;
                                console.log('üö´ Message cach√© apr√®s √©chec de lecture audio');
                            }, 8000); // 8 secondes d'affichage
                        }
                    }, 1000); // Attendre 1 seconde avant de r√©essayer
                }
            } catch (error) {
                console.error('‚ùå Erreur g√©n√©rale:', error);
                // Tenter d'afficher le message malgr√© l'erreur
                if (data && data.username && data.message) {
                    showMessage(data.username, data.message, data.voice);
                }
                // Nettoyer l'√©tat
                setTimeout(() => {
                    hideMessage();
                    currentAudio = null;
                    isProcessing = false;
                }, 8000); // 8 secondes d'affichage en cas d'erreur
            }
        }

        async function checkForNewMessage() {
            if (isProcessing) {
                // Si un nouveau message est d√©tect√© pendant le traitement, interrompre le traitement actuel
                try {
                    const response = await fetch('/current_message.json?' + Date.now());
                    if (!response.ok) return;
                    
                    const data = await response.json();
                    
                    if (data.timestamp && data.timestamp !== lastMessageId) {
                        console.log('üì• Nouveau message d√©tect√© pendant le traitement, interruption:', data);
                        // Arr√™ter l'audio actuel
                        if (currentAudio) {
                            currentAudio.pause();
                            currentAudio.src = '';
                            currentAudio.load();
                            currentAudio = null;
                        }
                        // Cacher le message actuel
                        hideMessage();
                        // R√©initialiser l'√©tat
                        isProcessing = false;
                        // Traiter le nouveau message
                        lastMessageId = data.timestamp;
                        isProcessing = true;
                        await playAudio(data);
                    }
                } catch (error) {
                    console.log('Erreur lors de la v√©rification de nouveaux messages pendant le traitement:', error);
                }
                return;
            }
            
            try {
                const response = await fetch('/current_message.json?' + Date.now());
                if (!response.ok) return;
                
                const data = await response.json();
                
                if (data.timestamp && data.timestamp !== lastMessageId) {
                    console.log('üì• Nouveau message d√©tect√©:', data);
                    lastMessageId = data.timestamp;
                    isProcessing = true;
                    await playAudio(data);
                }
            } catch (error) {
                console.log('Pas de nouveau message');
                isProcessing = false;
            }
        }

        // V√©rifier les nouveaux messages toutes les 200ms
        setInterval(checkForNewMessage, 200);
        console.log('‚úÖ Syst√®me TTS initialis√©');
    </script>
</body>
</html>
